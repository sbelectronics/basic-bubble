SECTION        bubble_lib
; Public symbols for linkage to basic-bubble board

	PUBLIC BBLREAD
	PUBLIC BBLWRIT
	PUBLIC BBLINIT
	PUBLIC BARL
	PUBLIC BARH

BBLBPP EQU	64D		; BUBBLE BYTES PER PAGE
BBLURA  EQU	0AH		; BUBBLE UTILITY REGISTER ADDRESS
BBLRLA	EQU	0BH		; BUBLE BLOCK LENGTH REGISTER LSB ADDRESS
BBLRHA	EQU	0CH		; BUBBLE BLOCK LENGTH REGISTER MSB ADDRESS
BBLERA	EQU	0DH		; BUBBLE ENABLE REGISTER ADDRESS
BARLA	EQU	0EH		; BUBBLE ADDRESS REGISTER LSB ADDRESS
BARHA	EQU	0FH		; BUBBLE ADDRESS REGISTER MSB ADDRESS
BFIFOA	EQU	00H		; BUBBLE FIFO REGISTER ADDRESS
                        					
; DEFAULT REGISTER VALUES

BBLRLV	EQU	01H		; DEFAULT 1 PAGE BLOCK LENGTH-USED BY BBL_INIT DO NOT CHANGE
BBLRHV	EQU	10H		; BLR MSB-64BYTE PAGE, 255 PAGES MAX
BBLEV	EQU	40H		; ENABLE VALUE- NO PARITY,NO INTERRUPT, NO DMA, ENABLE ECC
BARLV	EQU	00H		; DEFAULT ADDRESS LSB VALUE
BARHV	EQU	00H		; DEFAULT ADDRESS MSB VALUE
BARHCM	EQU	00000111B	; ADDRESS REGISTER MSB CLEAR MASK

; STATUS REGISTER MASKS

BSRBUCM	EQU	10000000B	; BUSY FLAG CLEAR MASK
BSROCCM	EQU	01000000B	; OPCODE COMPLETE FLAG CLEAR MASK
BSROFCM	EQU	00100000B	; OPCODE FAIL FLAG CLEAR MASK
BSRTECM	EQU	00010000B	; BUBBLE TIMING ERROR CLEAR MASK
BSRCECM	EQU	00001000B	; BUBBLE CORRECTABLE ERROR CLEAR MASK
BSRUECM	EQU	00000100B	; BUBBLE UNCORRECTABLE ERROR CLEAR MASK
BSRPECM	EQU	00000010B	; BUBBLE PARITY ERROR CLEAR MASK
BSRFFAC	EQU	00000001B	; 7220 FIFO AVAILABLE CLEAR MASK

BBLDAT	EQU	010H	        ; BUBBLE BASE (DATA) PORT
BBLCS	EQU	BBLDAT+1        ; COMMAND STATUS REGISTER PORT

; BASED ON SBC-85 BUBBLE MEMORY ROUTINES BY CRAIG ANDREWS, 2020
; COPYRIGHT 2019 (C) OF CRAIG ANDREWS ALL RIGHTS RESERVED

; COMMON ROUTINES
;
; READ/WRITE ROUTINES ARE IN BBLCOM.ACM

; ;*******************************************************************
; ;*************  BUBBLE ABORT  ;******************
;   NAME: BBLABRT
;   FUNCTION:SEND THE ABORT COMMAND TO THE 7220
;   INPUTS: NONE
;   OUTPUTS: RETURNS WITH BUBBLE STATUS IN ACCUMULATOR
;   USER IO: NONE
;   DESTROYS: A. F/F'S
;   CALLS: NOTHING
;   DESCRIPTION:SEND THE ABORT COMMAND TO 7220
; ; ;*******************************************************************
BBLABRT: 
	CALL BBLAB1
	CALL BBLAB1
	RET

BBLAB1:	
;	MVI	A,'A'		; UNCOMMENT FOR VERBOSE
;	CALL	CO		; UNCOMMENT FOR VERBOSE
	PUSH	D		; DE USED FOR TIMEOUT COUNTER, SAVE
	LXI	D,0FFFFH	; LOAD COUNTER START VALUE
	MVI	A,19H		; ABORT COMMAND FOR 7220
	OUT	BBLCS		; SEND TO COMMAND REGISTER
BBLABBS: 
	IN	BBLCS		; GET BUBBLE STATUS REGISTER
	RLC			; TEST BUSY BIT =1
	JC	BBLABP		;  NOT BUSY, LEAVE THIS LOOP FOR NEXT
	DCX	D		; DECREMENT TIMEOUT COUNTER
	XRA	A		; CLEAR ACCUMULATOR
	ORA	D		;  ADD ANY SET BITS IN D
	ORA	E		;  THEN SAME FOR E
	JNZ	BBLABBS		; TIMEOUT IS NOT ZERO, SO CONTINUE POLLING
	MVI	A,0E1H		; RETURN WITH ERROR 1
	JMP	BBLABDN		; DONE, BUT WITH TIMEOUT ERROR

BBLABP: 
	IN	BBLCS		; READ STATUS REGISTER
	CPI	BSROCCM		; ONLY SUCCESSFUL ANSWER IS OPCODE COMPLETE
	JZ	BBLABDN		; DONE WITH SUCCESS
	DCX	D		; DECREMENT TIMEOUT COUNTER
	XRA	A		; CLEAR A
	ORA	D		;  ADD ANY SET BETS IN D
	ORA	E		;  ADD ANY SET BITS IN E
	JNZ	BBLABP		; IF NOT TIMEOUT, CONTINUE POLLING FIFO RESET CMD
	MVI	A,0E2H		; RETURN WITH ERROR 2

BBLABDN: 
	POP	D
;	CALL	HO			; UNCOMMENT FOR VERBOSE
;	CALL	NEWLINE			; UNCOMMENT FOR VERBOSE

	RET			; RETURN

; ;*******************************************************************
; ;*************  BUBBLE FIFO RESET  ;******************
;   NAME: BBLFFR
;   FUNCTION:SEND THE FIFO RESET COMMAND TO THE 7220
;   INPUTS: NONE
;   OUTPUTS: RETURNS WITH BUBBLE STATUS IN ACCUMULATOR
;   USER IO: NONE
;   DESTROYS: A. F/F'S
;   CALLS: NOTHING
;   DESCRIPTION:SEND THE FIFO RESET COMMAND TO THE 7220 AND WAIT FOR
; 	THE OP-COMPLETE FLAG OR (BUSY OR COMPLETE) TIMEOUT, WHATEVER COMES FIRST
; ; ;*******************************************************************
BBLFFR: 
;  MVI	A,'F'			; UNCOMMENT FOR VERBOSE
;  CALL	CO
	PUSH	D		; DE USED FOR TIMEOUT COUNTER, SAVE
	LXI	D,0FFFFH	; LOAD COUNTER START VALUE
	MVI	A,1DH		; FIFO RESET COMMAND FOR 7220
	OUT	BBLCS		; SEND TO COMMAND REGISTER
BBLFFRB: 
	IN	BBLCS		; GET BUBBLE STATUS REGISTER
	RLC			; TEST BUSY BIT =1
	JC	BBLFFRP		;  NOT BUSY, LEAVE THIS LOOP FOR NEXT
	DCX	D		; DECREMENT TIMEOUT COUNTER
	XRA	A		; CLEAR ACCUMULATOR
	ORA	D		;  ADD ANY SET BITS IN D
	ORA	E		;  THEN SAME FOR E
	JNZ	BBLFFRB		; TIMEOUT IS NOT ZERO, SO CONTINUE POLLING
	MVI	A,0E3H		; RETURN WITH ERROR 3
	JMP	BBLFFRD		; DONE, BUT WITH TIMEOUT ERROR

BBLFFRP: 
	IN	BBLCS		; READ STATUS REGISTER
	CPI	BSROCCM		; ONLY SUCCESSFUL ANSWER IS OPCODE COMPLETE
	JZ	BBLFFRD		; DONE WITH SUCCESS
	DCX	D		; DECREMENT TIMEOUT COUNTER
	XRA	A		; CLEAR A
	ORA	D		;  ADD ANY SET BETS IN D
	ORA	E		;  ADD ANY SET BITS IN E
	JNZ	BBLFFRP		; IF NOT TIMEOUT, CONTINUE POLLING FIFO RESET CMD
	MVI	A,0E4H		; RETURN WITH ERROR 4 IN ACCUMULATOR

BBLFFRD: 
	POP	D
;  CALL HO			; UNCOMMENT FOR VERBOSE
;  CALL NEWLINE
	RET			; RETURN


; ;*******************************************************************
; ;*************  BUBBLE INITIALIZE  ;******************
;   NAME: BBLINIT
;   FUNCTION:INITIALIZES BUBBLE MEMORY SYSTEM
;   INPUTS: NONE
;   OUTPUTS: RETURNS WITH BUBBLE STATUS IN ACCUMULATOR
;   USER IO: NONE
;   DESTROYS: A. F/F'S
;   CALLS: BBLABRT, BBLPRL
;   DESCRIPTION:THIS COMMAND IS REQURIED AFTER POWERUP AND MUST PRECEED
; 	ALL OTHER COMMANDS. IT FIRST LOADS THE RAM PARAMETER BUFFERS WITH
; 	THE REQUIRED DEFAULT VALUES FOR INITIALIZATION, THEN ABORTS ANY
; 	EXISTING BUBBLE COMMAND THAT MAY BE PROCESSING, AND THEN INITIALIZES
; 	THE BUBBLE.  IT WILL RETURN IF ANYTHING RESULTS IN A TIMEOUT OR ANY
; 	STATUS OTHER THAN AN OPERATION COMPLETE STATUS.
; ; ;*******************************************************************
BBLINIT: 
;  MVI	A,'I'			; UNCOMMENT FOR VERBOSE
;  CALL	CO
	PUSH	D		; DE USED FOR TIMEOUT COUNTER, SAVE

	MVI	A,BBLRLV	; GET DEFAULT VALUE FOR BLOCK LENGTH LSB
	STA	BBLRL		; BUBBLE BLOCK LENGTH LSB -> BUFFER
	MVI	A,BBLEV		; GET ENABLE BYTE
	STA	BBLER		; BUBBLE ENABLE -> BUFFER
	MVI	A,BARLV		; GET DEFAULT BUBBLE ADDRESS LSB
	STA	BARL		; BUBBLE ADDRESS LSB-> BUFFER
	MVI	A,BARHV		; GET DEFAULT BUBBLE ADDRESS MSB
	STA	BARH		; BUBBLE ADDRESS MSB-> BUFFER
	CALL	BBLABRT		; ABORT ANY COMMANDS BEING PROCESSED
	CPI	BSROCCM		; ONLY SUCCESSFUL ANSWER IS OPCODE COMPLETE
	JNZ	BBLINID		; IF DIDN'T FINSIH ABORT, WE ARE DONE WITH ERROR
	CALL	BBLPRL		; PARAMETRIC REGISTER LOAD
	LXI	D,0FFFFH	; LOAD TIMEOUT LOOP COUNTER
	MVI	A,11H		; LOAD INITIALIZE BUBBLE COMMAND
	OUT	BBLCS		; SEND INITIALIZE COMMAND TO BUBBLE

BBLINIB: 
	IN	BBLCS		; GET BUBBLE STATUS REGISTER
	RLC			; TEST BUSY BIT =1
	JC	BBLINIP		;  NOT BUSY, LEAVE THIS LOOP FOR NEXT
	DCX	D		; DECREMENT TIMEOUT COUNTER
	XRA	A		; CLEAR ACCUMULATOR
	ORA	D		;  ADD ANY SET BITS IN D
	ORA	E		;  THEN SAME FOR E
	JNZ	BBLINIB		; TIMEOUT IS NOT ZERO, SO CONTINUE POLLING
	MVI	A,0E5H		; RETURN WITH ERROR 5
	JMP	BBLINID		; DONE, BUT WITH TIMEOUT ERROR

BBLINIP: 
	IN	BBLCS		; READ STATUS REGISTER
	CPI	BSROCCM		; ONLY SUCCESSFUL ANSWER IS OPCODE COMPLETE
	JZ	BBLINID		; DONE WITH SUCCESS
	ANI	030H		; CHECK FOR A TIMING ERROR
	CPI	030H		; UH OH...
	JZ	BBLINID		; BAIL OUT, AS THINGS AREN'T GOING TO GET BETTER
	DCX	D		; DECREMENT TIMEOUT COUNTER
	XRA	A		; CLEAR A
	ORA	D		;  ADD ANY SET BETS IN D
	ORA	E		;  ADD ANY SET BITS IN E
	JNZ	BBLINIP		; IF NOT TIMEOUT, CONTINUE POLLING FIFO RESET CMD
	MVI	A,0E6H

BBLINID: 

	POP	D
;  CALL	HO			; UNCOMMENT FOR VERBOSE
;  CALL	NEWLINE
	RET			; RETURN


; ;*******************************************************************
; ;*************  BUBBLE PARAMETRIC REGISTER LOAD  ;******************
;   NAME: BBLPRL
;   FUNCTION: FILLS BUBBLE PARAMETRIC REGISTERS WITH VALUES IN RAM BUFFER
;   INPUTS: NONE
;   OUTPUTS: NONE
;   USER IO: NONE
;   DESTROYS: A. F/F'S
;   CALLS: NOTHING
;   DESCRIPTION:SENDS THE PARAMETRIC REGISTER VALUES HELD IN RESERVED RAM
; 	LOCATIONS TO BUBBLE 7220. ENDS WITH PARAMETRIC REGISTER ADDRESS POINTING
; 	TO 7220 FIFO
; 	THE ENABLE REGISTER AND BLOCK LENGTH MSB ARE HARD CODED
; ; ;*******************************************************************
BBLPRL: 
;  MVI A,'P'			; UNCOMMENT FOR VERBOSE
;  CALL CO
	MVI	A,BBLRLA	; GET STARTING REGISTER NUMBER
	OUT	BBLCS		; SET 7220 REGISTER POINTER TO BLR LSB
;  CALL HO			; UNCOMMENT FOR VERBOSE
;  mvi a,' '
;  CALL CO
;  MVI A,'b'
;  CALL CO
	LDA	BBLRL		; GET BLOCK LENGTH LSB VALUE FROM RAM BUFFER
	OUT	BBLDAT		; LOAD IN BLOCK LENGTH LSB REGISTER
;  CALL HO			; UNCOMMENT FOR VERBOSE
	MVI	A,BBLRHV	; GET BLOCK LENGTH MSB VALUE
	OUT	BBLDAT		; LOAD IN BLOCK LENGTH MSB REGISTER
;  CALL HO			; UNCOMMENT FOR VERBOSE
;  mvi a,' '
;  CALL CO			; UNCOMMENT FOR VERBOSE
;  MVI A,'e'
;  CALL CO			; UNCOMMENT FOR VERBOSE
	LDA	BBLER		; GET ENABLE REGISTER VALUE
	OUT	BBLDAT		; LOAD IN BUBBLE ENABLE REGISTER
;  CALL HO			; UNCOMMENT FOR VERBOSE
;  mvi a,' '
;  CALL CO			; UNCOMMENT FOR VERBOSE
;  MVI A,'a'
;  CALL CO
	LDA	BARL		; GET ADDRESS LSB
	OUT	BBLDAT		; LOAD IN BUBBLE AR_L REGISTER
;  CALL HO
	LDA	BARH		; GET ADDRESS MSB
	OUT	BBLDAT		; LOAD INTO BUBBLE ADDRESS MSB REGISTER
;  CALL HO			; UNCOMMENT FOR VERBOSE
;  mvi a,' '
;  CALL CO
;  MVI	A,'s'
;  CALL	CO			; UNCOMMENT FOR VERBOSE

	IN	BBLCS		; GET STATUS BEFORE RETURN
;  CALL	HO			; UNCOMMENT FOR VERBOSE

	RET			; DONE LOADING 7220 REGISTERS, RETURN

; ;*******************************************************************
; ;**********  BUBBLE CALCULATE AND LOAD BLOCK LENGTH  ;**************
;   NAME: BBLCLBL
;   FUNCTION: CALCULATES THE BLOCK LENGTH AND LOADS INTO BUFFER FOR REGISTER LOAD
;   INPUTS: HL=NUMBER OF BYTES TO READ OR WRITE
;   OUTPUTS: BLOCK LENGTH LOADED INTO LSB REGISTER
;   USER IO: NONE
;   DESTROYS: A,F/F'S
;   CALLS:
;   DESCRIPTION:
; 	TO USE SUBROUTINE:
; 	HL <- NUMBER OF BYTES TO TRANSFER
; 	RESULT: CALCULATED BLOCK LENGTH -> BBLRL
;   EXAMPLE: HL=40 --> 01R04
; ; ;*******************************************************************
BBLCLBL:  
	PUSH	B		; B=# OF PAGES, C=NUMBER OF BYTES LEFT ON THIS PAGE
	PUSH	H		; SAVE THE ORIGINAL COUNT
;  CALL	SENDHL			; UNCOMMENT FOR VERBOSE
	MVI	C,BBLBPP	; BUBBLE BYTES PER PAGE VALUE
	MVI	B,01D		; STARTING VALUE = 1 PAGE


BBLCLLP: 
	DCR	C
	JP P,	BBLCL1		; IF BYTES LEFT ON THIS PAGE, CONTINUE
	MVI	C,BBLBPP-1	; RELOAD BYTES PER PAGE
	INR	B		; SPILL OVER INTO ANOTHER PAGE SO INCREASE PAGE COUNT

BBLCL1: 
	DCX	H		; DECREMENT NUMBER OF BYTES LEFT
	XRA	A		; CLEAR ACCUMULATOR
	ORA	H		; SEE IF BYTE COUNT IS ZERO BY ADDING BITS TO ACCUMULATOR
	ORA	L		; FIRST H THEN L
	JNZ	BBLCLLP		; NOT ZERO, DO ANOTHER BYTE

;  MVI A,'='			; UNCOMMENT FOR VERBOSE
;  CALL CO			; UNCOMMENT FOR VERBOSE
	MOV	A,B		; MOVE NUMBER OF PAGES (BLOCKS) NEEDED INTO A
	STA	BBLRL		; NUMBER OF BLOCKS USED ROUNDED UP -> BUFFER
;  CALL HO			; UNCOMMENT FOR VERBOSE
;  MVI A,'r'			; UNCOMMENT FOR VERBOSE
;  CALL CO			; UNCOMMENT FOR VERBOSE
	MOV	A,C
	STA	BBLPUC		; NUMBER OF EMPTY PLACES LEFT IN PAGE  -> BUFFER
;  CALL	HO			; UNCOMMENT FOR VERBOSE
;  CALL	NEWLINE			; UNCOMMENT FOR VERBOSE
	POP	H
	POP	B
 	RET

; BASED ON SBC-85 BUBBLE MEMORY ROUTINES BY CRAIG ANDREWS, 2020
; COPYRIGHT 2019 (C) OF CRAIG ANDREWS ALL RIGHTS RESERVED

; READ/WRITE ROUTINES

; ;*******************************************************************
; ;*************  BUBBLE GET DATA AND SAVE INTO RAM  ;******************
;   NAME: BBLGET
;   FUNCTION: READS BUBBLE DATA AND PUTS INTO RAM
;   INPUTS: DE=STARTING ADDRESS OF RAM, HL=NUMBER OF BYTES TO WRITE
;   OUTPUTS: NONE
;   USER IO: NONE
;   DESTROYS: A,H,L, F/F'S
;   CALLS: NOTHING
;   DESCRIPTION:
; 	TO USE SUBROUTINE:
; 	LOAD LSB OF BLOCK LENGTH IN BBLRL
; 	LOAD LSB OF BUBBLE ADDRESS INTO BARL
; 	LOAD MSB OF BUBBLE ADDRESS INTO BARH
; 	LOAD NUMBER OF BYTES TO TRANSFER INTO HL REGISTER PAIR
; 	LOAD STARTING ADDRESS OF RAM TO SAVE DATA INTO DE REGISTER PAIR
; 	CALL BBLREAD
; ; ;*******************************************************************
BBLGET: 
;  CALL	NEWLINE			; UNCOMMENT FOR VERBOSE
;  MVI	A,'R'			; UNCOMMENT FOR VERBOSE
;  CALL	CO			; UNCOMMENT FOR VERBOSE

	PUSH	D		; SAVE NUMBER OF BYTES
	PUSH	B		; USED IN THIS ROUTINE
	LXI	B,0FFFFH	; LOAD TIMEOUT COUNTER
	MVI	A,12H		; LOAD READ BUBBLE MEMORY DATA COMMAND
	OUT	BBLCS		; SEND COMMAND TO 7220 COMMAND REGISTER
BBLGETB: 
	DCX	B		; DECREMENT TIMEOUT COUNTER
	XRA	A		; CLEAR ACCUMULATOR
	ORA	B		; SEE IF ANY B BITS SET
	ORA	C		; SEE IF ANY C BITS SET
	MVI	A,0EAH		; PRELOAD ERROR CODE
	JZ	BBLGETD		; IF ZERO, DONE BECAUSE OF TIMEOUT ERROR
	IN	BBLCS		; OTHERWISE, GET STATUS REGISTER
	RLC			; PUT BUSY BIT INTO CARRY
	JNC	BBLGETB		; LOOP UNTIL BUBBLE SETS BUSY INDICATING RECEIPT


BBLGETP: 
	IN	BBLCS		; GET BUBBLE STATUS
	RRC			; PUT FIFO AVAILABLE BIT INTO CARRY
	JC	BBLGETR		; SOMETHING IN FIFO, SO READ BYTE

	IN	BBLCS		; GET BUBBLE STATUS
	RLC			; TEST BUSY BIT
	MVI	A,0EBH		; PRELOAD ERROR B JUST IN CASE
	JNC	BBLGETD		; NOT BUSY, SO DONE BUT WITH ERROR

	DCX	B		; DECREMENT TIMEOUT COUNTER
	XRA	A		; CLEAR ACCUMULATOR
	ORA	B		; SET ANY BITS IN B THAT ARE SET
	ORA	C		; DO THE SAME FOR ANY BITS IN C
	MVI	A,0ECH		; PRELOAD ERROR C JUST IN CASE
	JZ	BBLGETD		; DONE DUE TO TIMEOUT ERROR
	JMP	BBLGETP		; HAVE NOT TIMED OUT, SO LOOP AGAIN

BBLGETR: 
	LXI	B,0FFFFH	; RESET TIMEOUT COUNTER
	IN	BBLDAT		; READ BYTE FROM BUBBLE
	STAX	D		; MOVE DATA BYTE INTO DE REGISTER ADDRESS
	INX	D		; INCREMENT TO NEXT MEMORY ADDRESS

	DCX	H		; DECREMENT DATA BYTE COUNTER
	XRA	A		; CLEAR ACCUMULATOR
	ORA	H		; ADD ANY BITS THAT ARE SET IN H
	ORA	L		; AND THEN ANY BITS SET IN L
	JNZ	BBLGETP		; LOOP UNTIL ALL BYTES ARE DONE OR ERROR OCCURS

;                                 NOW FLUSH OUT THE REMAINDER OF THE PAGE FROM FIFO
	LDA	BBLPUC		; GET THE PAGE UNUSED COUNT
	MOV	L,A		; PUT INTO L
	ORA	A		; SEE IF THERE IS A REMAINDER
 	JZ	BBLGETD		; NOPE, ALL DONE


BBLGFP: 
	IN	BBLCS		; GET BUBBLE STATUS
	RRC			; PUT FIFO AVAILABLE BIT INTO CARRY
	JC	BBLGFRD		; SOMETHING IN FIFO, GET IT
	IN	BBLCS		; GET BUBBLE STATUS
	RLC			; TEST BUSY BIT
	MVI	A,0EDH		; PRELOAD ERROR D
	JNC	BBLGETD		; NOT BUSY SO....DONE I GUESS?
	DCX	B		; DECREMENT TIMEOUT COUNTER
	XRA	A		; CLEAR ACCUMULATOR
	ORA	B		; SET ANY BITS IN B THAT ARE SET
	ORA	C		; DO THE SAME FOR ANY BITS IN C
	MVI	A,0EEH		; PRELOAD ERROR CODE
	JZ	BBLGETD		; DONE DUE TO TIMEOUT ERROR
	JMP	BBLGFP		; HAVE NOT TIMED OUT, SO LOOP AGAIN

BBLGFRD: 
	IN	BBLDAT		; GET BYTE FROM BUBBLE -> BITBUCKET
	DCR	L		; DECREMENT REMAINDER COUNTER
	JNZ	BBLGFP		; AND READ FROM FIFO UNTIL LAST DONE


BBLGETD: 
;  CALL HO			; UNCOMMENT FOR VERBOSE
;  CALL NEWLINE			; UNCOMMENT FOR VERBOSE
	POP	B		; RESTORE BC
	POP	D		; RESTORE DE
	RET			; RETURN TO CALL

; ;*******************************************************************
; ;*************  BUBBLE PUT DATA FROM RAM INTO BUBBLE  ;******************
;   NAME: BBLPUT
;   FUNCTION: WRITES MEMORY DATA TO THE BUBBLE
;   INPUTS: DE=STARTING ADDRESS OF DATA, HL=NUMBER OF BYTES TO WRITE
;   OUTPUTS: NONE
;   USER IO: NONE
;   DESTROYS: A,H,L, F/F'S
;   CALLS: NOTHING
;   DESCRIPTION:
; 	TO USE SUBROUTINE:
; 	LOAD LSB OF BLOCK LENGTH IN BBLRL
; 	LOAD LSB OF BUBBLE ADDRESS INTO BARL
; 	LOAD MSB OF BUBBLE ADDRESS INTO BARH
; 	LOAD NUMBER OF BYTES TO TRANSFER INTO HL REGISTER PAIR
; 	LOAD STARTING MEMORY ADDRESS OF DATA TO BE SAVED INTO DE REGISTER PAIR
; 	CALL BBLWRIT
; ; ;*******************************************************************
BBLPUT: 
;  CALL NEWLINE			; UNCOMMENT FOR VERBOSE
;  MVI A,'W'			; UNCOMMENT FOR VERBOSE
;  CALL CO			; UNCOMMENT FOR VERBOSE
	PUSH	D		; SAVE NUMBER OF BYTES
	PUSH	B		; USED IN THIS ROUTINE FOR TIMEOUT COUNTER
	LXI	B,0FFFFH	; LOAD TIMEOUT COUNTER
	MVI	A,13H		; LOAD WRITE BUBBLE MEMORY DATA COMMAND
	OUT	BBLCS		; SEND COMMAND TO 7220 COMMAND REGISTER
BBLPUTB: 
	DCX	B		; DECREMENT TIMEOUT COUNTER
	XRA	A		; CLEAR ACCUMULATOR
	ORA	B		; SEE IF ANY B BITS SET
	ORA	C		; SEE IF ANY C BITS SET
	MVI	A,0EAH		; PRELOAD ERROR CODE
	JZ	BBLPUTD		; IF ZERO, DONE BECAUSE OF TIMEOUT ERROR
	IN	BBLCS		; OTHERWISE, GET STATUS REGISTER
	RLC			; PUT BUSY BIT INTO CARRY
	JNC	BBLPUTB		; WAIT UNTIL BUSY GOES INDICATING RECEIPT OF COMMAND

BBLPUTP: 
	IN	BBLCS		; GET BUBBLE STATUS
	RRC			; PUT FIFO READY BIT INTO CARRY
	JC	BBLPUTW		; ROOM IN FIFO, SO ADD A BYTE
	IN	BBLCS		; GET BUBBLE STATUS
	RLC			; TEST BUSY BIT
	MVI	A,0EBH		; PRELOAD ERROR CODE
	JNC	BBLPUTD		; NOT BUSY, SO DONE BUT WITH ERROR

	DCX	B		; DECREMENT TIMEOUT COUNTER
	XRA	A		; CLEAR ACCUMULATOR
	ORA	B		; SET ANY BITS IN B THAT ARE SET
	ORA	C		; DO THE SAME FOR ANY BITS IN C
	MVI	A,0ECH		; PRELOAD ERROR CODE
	JZ	BBLPUTD		; DONE DUE TO TIMEOUT ERROR
	JMP	BBLPUTP		; HAVE NOT TIMED OUT, SO LOOP AGAIN

BBLPUTW: 
	LXI	B,0FFFFH	; RESET TIMEOUT COUNTER
	LDAX	D		; LOAD DATA FROM DE REGISTER ADDRESS
	OUT	BBLDAT		; SEND TO BUBBLE FIFO
	INX	D		; INCREMENT TO NEXT MEMORY ADDRESS

	DCX	H		; DECREMENT DATA BYTE COUNTER
	XRA	A		; CLEAR ACCUMULATOR
	ORA	H		; ADD ANY BITS THAT ARE SET IN H
	ORA	L		; AND THEN ANY BITS SET IN L
	JNZ	BBLPUTP		; LOOP UNTIL ALL BYTES ARE DONE OR ERROR OCCURS

	LDA	BBLPUC		; GET THE PAGE UNUSED COUNT
	MOV	L,A		; PUT INTO L

;                                 NOW NEED TO FILL UP THE REMAINDER OF THE PAGE
	ORA	A		; SEE IF THERE IS A REMAINDER
 	JZ	BBLPUTD		; NOPE, ALL DONE

BBLPFP: 
	IN	BBLCS		; GET BUBBLE STATUS
	RRC			; PUT FIFO AVAILABLE BIT INTO CARRY
	JC	BBLPFW		; ROOM IN FIFO, SO ADD A BYTE
	IN	BBLCS		; GET BUBBLE STATUS
	RLC			; TEST BUSY BIT
	MVI	A,0EDH		; PRELOAD ERROR CODE
	JNC	BBLPUTD		; NOT BUSY SO....DONE I GUESS?
	DCX	B		; DECREMENT TIMEOUT COUNTER
	XRA	A		; CLEAR ACCUMULATOR
	ORA	B		; SET ANY BITS IN B THAT ARE SET
	ORA	C		; DO THE SAME FOR ANY BITS IN C
	MVI	A,0EEH		; PRELOAD ERROR CODE
	JZ	BBLPUTD		; DONE DUE TO TIMEOUT ERROR
	JMP	BBLPFP		; HAVE NOT TIMED OUT, SO LOOP AGAIN

BBLPFW: 
 	MOV	A,L		; LOAD REMAINDER COUNTER, SAVE AS DATA BYTE (DIAGNOSTIC)
	OUT	BBLDAT		; SEND TO BUBBLE FIFO
	DCR	L		; DECREMENT REMAINDER COUNTER
	JNZ	BBLPFP		; AND OUTPUT NEXT FILLER UNTIL DONE

BBLPUTD: 
	IN	BBLCS		; GET BUBBLE STATUS
;  CALL HO			; UNCOMMENT FOR VERBOSE
;  CALL NEWLINE			; UNCOMMENT FOR VERBOSE
	POP	B		; RESTORE BC
	POP	D		; RESTORE DE
	RET			; RETURN TO CALL

; ;*******************************************************************
; ;*************  BUBBLE READ DATA FROM BUBBLE INTO RAM  ;******************
;   NAME: BBLREAD
;   FUNCTION: READS BUBBLE DATA AND PUTS INTO RAM
;   INPUTS: DE=STARTING ADDRESS OF DATA, HL=NUMBER OF BYTES TO WRITE
;   OUTPUTS: RETURNS WITH BUBBLE STATUS IN ACCUMULATOR. 40H OR 42H = SUCCESS
;   USER IO: NONE
;   DESTROYS: A,F/F'S
;   CALLS: BBLFFR,BBL_LPR,BBL_BYTES,BBLPUT
;   DESCRIPTION:
; 	TO USE SUBROUTINE:
; 	BARL <- LSB OF BUBBLE ADDRESS
; 	BARH <- MSB OF BUBBLE ADDRESS
; 	HL <- NUMBER OF BYTES TO TRANSFER
; 	DE <- STARTING RAM ADDRESS OF DESTINATION
; 	CALL BBLREAD
; ; ;*******************************************************************
BBLREAD: 
	DI			; DISABLE INTERRUPTS
	PUSH	D		; SAVE DE
	PUSH	H		; SAVE HL
	CALL	BBLABRT		; ABORT ANY COMMANDS BEING PROCESSED
	CALL	BBLFFR		; CALL BUBBLE FIFO RESET ROUTINE
	XRI	BSROCCM		; ONLY SUCCESSFUL ANSWER IS OPCODE COMPLETE
	JNZ	BBLRDDN		; IF DIDN'T FINSIH ABORT, WE ARE DONE WITH ERROR
	CALL	BBLCLBL		; CALCULATE AND LOAD BLOCK LENGTH TO BUFFER
	MVI	A,BBLEV		; GET ENABLE BYTE VALUE
	STA	BBLER		; BUBBLE ENABLE VALUE  -> BUFFER
	CALL	BBLPRL		; CALL LOAD PARAMETRIC REGISTER
	CALL	BBLGET		; READ BUBBLE DATA
	LXI	H,0FFFFH	; INITIALIZE TIMEOUT COUNTER
BBLRDLP: 
	IN	BBLCS		; GET BUBBLE STATUS
	RLC			; PUT BUSY BIT INTO CARRY
	JNC	BBLRDDN		; IF NOT BUSY, RETURN
	DCX	H		; DECREMENT TIMEOUT COUNTER
	XRA	A		; CLEAR ACCUMULATOR
	ORA	H		; SET ANY BITS IN H THAT ARE SET
	ORA	L		; DO THE SAME FOR ANY BITS IN L
	JNZ	BBLRDLP		; HAVE NOT TIMED OUT, SO LOOP AGAIN

BBLRDDN: 
	POP	H		; RESTORE HL
	POP	D		; RESTORE DE
	IN	BBLCS		; GET BUBBLE STATUS
	EI			; ENABLE INTERRUPTS
	RET			; RETURN TO CALL

; ;*******************************************************************
; ;*************  BUBBLE WRITE DATA FROM RAM INTO BUBBLE  ;******************
;   NAME: BBLWRIT
;   FUNCTION: WRITES MEMORY DATA TO THE BUBBLE
;   INPUTS: DE=STARTING ADDRESS OF DATA, HL=NUMBER OF BYTES TO WRITE
;   OUTPUTS: RETURNS WITH BUBBLE STATUS IN ACCUMULATOR. 40H OR 42H = SUCCESS
;   USER IO: NONE
;   DESTROYS: A,F/F'S
;   CALLS: BBLFFR,BBL_LPR,BBL_BYTES,BBLPUT
;   DESCRIPTION:
; 	TO USE SUBROUTINE:
; 	BARL <- LSB OF BUBBLE ADDRESS
; 	BARH <- MSB OF BUBBLE ADDRESS
; 	HL <- NUMBER OF BYTES TO TRANSFER
; 	DE <- STARTING MEMORY ADDRESS OF SOURCE DATA
; 	CALL BBLWRIT
; ; ;*******************************************************************
BBLWRIT: 
	DI			; DISABLE INTERRUPTS
	PUSH	H		; SAVE HL
	CALL	BBLABRT		; ABORT ANY COMMANDS BEING PROCESSED
	CALL	BBLFFR		; CALL BUBBLE FIFO RESET ROUTINE
	XRI	BSROCCM		; ONLY SUCCESSFUL ANSWER IS OPCODE COMPLETE
	JNZ	BBLWRDN		; IF DIDN'T FINISH ABORT, WE ARE DONE BUT WITH ERROR
	CALL	BBLCLBL		; CALCULATE AND LOAD BLOCK LENGTH TO BUFFER
	MVI	A,BBLEV		; GET ENABLE BYTE VALUE
	STA	BBLER		; BUBBLE ENABLE VALUE  -> BUFFER
	CALL	BBLPRL		; CALL LOAD PARAMETRIC REGISTER
	CALL	BBLPUT		; WRITE BUBBLE DATA
	LXI	H,0FFFFH	; INITIALIZE TIMEOUT COUNTER
BBLWRLP: 
	IN	BBLCS		; GET BUBBLE STATUS
	RLC			; TEST FOR BUSY BIT
	JNC	BBLWRDN		; IF NOT BUSY, CLEAN UP AND RETURN
	DCX	H		; IF STILL BUSY, DECREMENT TIMEOUT COUNTER
	XRA	A		; CLEAR ACCUMULATOR
	ORA	H		; SET ANY BITS IN H THAT ARE SET
	ORA	L		; DO THE SAME FOR ANY BITS IN L
	JNZ	BBLWRLP		; HAVE NOT TIMED OUT, SO LOOP AGAIN

BBLWRDN: 
	POP	H		; RESTORE HL
	IN	BBLCS		; GET BUBBLE STATUS
	EI			; ENABLE INTERRUPTS
	RET			; RETURN TO CALL


;	CHUNKED READ AND WRITE ROUTINES

BBLCSZ  EQU	020H		; Chunk size times 256

;*	NEXT CHUNK
;
;	ADJUST DE, HL, AND BAR TO POINT TO NEXT CHUNK

NEXTCNK:	MOV	A,D		; Increment DE by one chunk
	ADI	BBLCSZ
	MOV	D,A

	MOV	A,H		; Decrement HL by one chunk
	SUI	BBLCSZ
	MOV	L,A

	LDA	BARL		; Increment BAR by the chunk size
	ADI	BBLCSZ*4
	STA	BARL
	RNC
	LDA	BARH
	INR	A
	STA	BARH
	RET

;*	READ DATA
;
;	BC = BYTE COUNT
;	DE = SRC ADDRESS
;	BARL/BARH = BUBBLE BLOCK
;
;	MODIFIES BARL/BARH

BREADC:  
	PUSH	B		; Save caller args
	PUSH	D
	PUSH	H
	MOV	H,B		; BC INTO HL		
	MOV	L,C

RNEXT16:	MOV     A,H
	CPI	BBLCSZ+1	; Bigger than a chunk?
	JC	LASTRD		; Nope.
	PUSH	D
	PUSH	H
	MVI	H,BBLCSZ	; Set size to 1 chunk
	MVI	L,0
	CALL	BBLREAD		; Read the chunk
	POP	H
	POP	D

	CALL	NEXTCNK		; Point to next Chunk

	JMP	RNEXT16

LASTRD:	CALL	BBLREAD		; We are almost done, less than 16K+1sector remaining
	POP	H
	POP	D
	POP	B
	ANA	A
	RET

;*	WRITE DATA
;
;	BC = BYTE COUNT
;	DE = SRC ADDRESS
;	BARL/BARH = BUBBLE BLOCK
;
;	MODIFIES BC, DE, BARL/BARH

BWRITEC:	
	PUSH	B		; Save caller args
	PUSH	D
	PUSH	H
	MOV	H,B		; BC INTO HL		
	MOV	L,C

WNEXT16:	MOV     A,H
	CPI	BBLCSZ+1	; Bigger thank a chunk?
	JC	LASTWR		; Nope.
	PUSH	D
	PUSH	H
	MVI	H,BBLCSZ	; Set size to 1 chunk
	MVI	L,0
	CALL	BBLWRIT		; Write the chunk
	POP	H
	POP	D

	CALL	NEXTCNK		; Point to next Chunk

	JMP	WNEXT16

LASTWR:	CALL	BBLWRIT		; We are almost done, less than 16K+1sector remaining
	POP	H
	POP	D
	POP	B
	ANA	A
	RET


SECTION        bubble_vars
; BASED ON SBC-85 BUBBLE MEMORY ROUTINES BY CRAIG ANDREWS, 2020
; COPYRIGHT 2019 (C) OF CRAIG ANDREWS ALL RIGHTS RESERVED

BUR:	DS	1		; BUBBLE UTILITY REGISTER
BBLRL:	DS	1		; BUBBLE BLOCK LENGTH REGISTER LSB
BBLER:	DS	1		; BUBBLE ENABLE REGISTER
BAR:	
BARL:	DS	1		; BUBBLE ADDRESS REGISTER LSB
BARH:	DS	1		; BUBBLE ADDRESS REGISTER MSB
BBLPUC:	DS	1		; BUBBLE PAGE UNUSED COUNT (BYTES)

